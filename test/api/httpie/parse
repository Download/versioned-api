#!/usr/bin/env node

const fs = require('fs')

function parseHeaders (headerLines) {
  return headerLines.reduce((result, line) => {
    const [key, value] = line.split(':')
    result[key] = value
    return result
  }, {})
}

function getIn (obj, path) {
  let result = obj
  for (const key of path) {
    const value = (result && result[key])
    if (value == null) {
      return undefined
    } else {
      result = value
    }
  }
  return result
}

function readStdin (callback) {
  let input = ''
  process.stdin.on('readable', () => {
    const chunk = process.stdin.read()
    if (chunk) input += chunk
  })
  process.stdin.on('end', function () {
    callback(input.trim())
  })
}

// NOTE: httpie output layout:
// request method, path
// request headers
// \r\n\r\n
// {request body}
// \n\n
// response status \r\n
// response headers
// \r\n\r\n
// {response body}
function parse (parsePath, output) {
  const [response, responseBody] = output.split(/\r\n\r\n|\n\n/).slice(2)
  const [responseLine, ...responseHeaderLines] = response.split('\r\n')
  const responseHeaders = parseHeaders(responseHeaderLines)
  const status = responseLine.split(' ')[1]

  if (parsePath === 'status') {
    console.log(status)
  } else if (parsePath === 'headers') {
    console.log(responseHeaders)
  } else if (parsePath.startsWith('headers')) {
    const header = parsePath.split('.')[1]
    console.log(responseHeaders[header])
  } else if (parsePath === 'body') {
    console.log(responseBody)
  } else if (parsePath.startsWith('body')) {
    const path = parsePath.split('.').slice(1)
    const result = getIn(JSON.parse(responseBody), path)
    if (typeof result === 'object') {
      console.log(JSON.stringify(result))
    } else {
      console.log(result)
    }
  }
}

const args = process.argv.slice(2)
if (args.length === 2) {
  const [parsePath, filePath] = args
  const output = fs.readFileSync(filePath).toString()
  parse(parsePath, output)
} else if (args.length === 1) {
  const parsePath = args[0]
  readStdin(output => parse(parsePath, output))
} else {
  throw new Error('Must provide one or two arguments - a parsePath (status|headers|body) and optionally a file path (or stdin)')
}
